Iterator Pattern
===============================

*The Iterator Pattern* provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

Indications
-----
* You have objects in a collection the clients want to iterate over, but you don't want the clients to have access to the implementation.

New OO Principles
-------------------
1. A class should have only one reason to change.


Refactoring Steps
-----
* p. 324-5: The Diner and Pancake Houses agree on the MenuItem class...
* p. 326-7: ...but each has implemented the menu differently. The Pancake House uses ArrayList, and the Diner uses Array, and each have menu methods dependent on their own implementations. Note: C# ArrayList behaves differently from Java's (need to re-cast the generic objects in C#).
* p. 328: The Java-enabled waitress has a specification which can be achieved using the Iteration Pattern.
* p. 329: GetMenuItems() requires two loops. If another restaurant with a different implementation is acquired then we'll have _three_ loops.
* p. 331: Even with a for loop, Waitress still needs to know about the type of each menu. Need to decouple the Waitress from the concrete implementations of the menus completely.
* p. 332: Encapsulate what varies: in this case, that's the iteration over MenuItems.
* p. 333-5: Implenting the Iterator Pattern. Added Iterator interface and DinerMenuIterator.
* p. 336: Added CreateIterator() to DinerMenu. Did same updates for PancakeHouseMenu.
* p. 337: Reworked Waitress to use Iterator interface. For C#, need to explicitly cast (MenuItem) returned by Iterator.Next().
* p. 338: Test drive it.
* p. 339: Waitress is still bound to two concrete Menu classes...
* p. 341: HFDP switches to Java's Iterator interface. C# doesn't have anything that maps directly. Could use IEnumerator<MenuItem>, but I've decided it's not worth my bothering. Instead, added generic type to Iterator interface (Iterator<T>). Did not implement Remove().
* p. 351: Added CafeMenu.

Lessons
-------
* Iterator Pattern gives a uniform way of accessing elements of aggregate objects, allowing polymorphic code.
* Iterator Pattern moves responsiblity of traversing elements from the aggregate object to the iterator object.
* Every responsibility of a class is an area of potential change. More than one responsibility means more than one area of change.
* Cohesion: Measure (high or low) of how closely a class or module supports a single purpose or responsibility.